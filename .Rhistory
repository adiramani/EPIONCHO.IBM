OAE_incidence_DT_under_5 <- new_inc_under_5 # record & update incidence in 3 to 5 age group
OAE_incidence_DT_5_10 <- new_inc_5_10 # record & update incidence in 5 to 10 age group
OAE_incidence_DT_11_15 <- new_inc_11_15 # record & update incidence in 10 to 15 age group
OAE_incidence_DT_M <- new_inc_M # record & update incidence in males
OAE_incidence_DT_F <- new_inc_F # record & update incidence in females
# # if taking straight from eq input
# prev_OAE <- OAE_infection[[1]] # calculate & update prevalence of OAE
#
# OAE_incidence_DT <- OAE_infection[[2]] # record + update number of new OAE cases
#
# OAE_incidence_DT_3_5 <- OAE_infection[[3]] # record & update incidence in 3 to 5 age group
# OAE_incidence_DT_5_10 <- OAE_infection[[4]] # record & update incidence in 5 to 10 age group
#
# OAE_incidence_DT_M <- OAE_infection[[5]] # record & update incidence in males
# OAE_incidence_DT_F <- OAE_infection[[6]] # record & update incidence in females
}
}
i <- 1
# ================================================================================================= #
#               Main loop for running through processes in model with i > 1                         #
while(i < time.its) #over time
{
# if(isTRUE(print_progress) & (any(i == year_its))) {print(paste(round(i * DT, digits = 2), 'yrs;',
#                                                                (paste(round(i/time.its * 100, digits = 1), '%', sep=' '))))}
#stores mean L3 and adult worms from previous timesteps
all.mats.cur <- all.mats.temp
# extract element from treat.prob.variable depending on specific treatment round (iteration in times.of.treat.in) #
if(all(!is.na(treat.prob.variable))){
if(any(i == times.of.treat.in)) {
index.iter.treat <- match(i, times.of.treat.in) # find element where iteration number matches a time in times.of.treat vector
treat.prob <- treat.prob.variable[index.iter.treat]} # index prob value from treat.prob.variable vector
}
# if IVM/MOX switch included, specify which treatment parameters to use if treatment iteration
if(all(!is.na(treat.switch))){
if(any(i == times.of.treat.in)) {
index.iter.treat <- match(i, times.of.treat.in) # find element where iteration number matches a time in times.of.treat vector
treat.type <- treat.switch[index.iter.treat] # index IVM or MOX value from treat.switch.in vector
if(treat.type == "IVM"){
lam.m = 32.4; phi = 19.6 # treatment induced embryostatic parameters
cum.infer= 0.345 # permanent infertility in worms
up = 0.0096; kap = 1.25 # microfilaricidal effect curve parameters
print("IVM parameters updated")
}
if(treat.type == "MOX"){
lam.m = 462; phi = 4.83 # treatment induced embryostatic parameters
cum.infer= 0.345 # permanent infertility in worms
up = 0.04; kap = 1.82 # microfilaricidal effect curve parameters
print("MOX parameters updated")
}
if(!(treat.type %in% c("MOX", "IVM"))){
print("ERROR - either IVM or MOX not specified in treatment switch vector at this iteration")
}
}
}
# to track variable coverage
if(i >= treat.start & i <= treat.stop & give.treat == 1){
coverage.upd <- treat.prob
} else
{coverage.upd <- 0}
# ========================= #
# old coverage              #
# which individuals will be treated if treatment is given (old compliance approach)
if(i >= treat.start & give.treat ==1 & correlated_compliance != "YES") {
cov.in <- os.cov(all.dt = all.mats.cur, pncomp = pnc, covrg = treat.prob, N = N)
}
# ============================= #
# for new compliance structure;
# initialize probability of treatment values (pTreat) for each individual if first round
# subsequent rounds: check to see if coverage or correlation par values have changed since last treatment,
# if so, need to edit pTreat values
# always check for zero values in pTreat for subsequent rounds
if(correlated_compliance == "YES" & any(i == times.of.treat.in)){
probneverTreat <- pnc
cov <- treat.prob
# first MDA round
if(i == times.of.treat.in[1]){
# specify neever treat individuals
compliance.mat <- matrix(nrow=N, ncol=6) # col 1 = age, col 2 = never_treat,
# col 3 = probability of treatment, col 4 = to be treated in this round
compliance.mat[,2] = generateNeverTreat(N = N, probneverTreat) # never treat col (mat[,1])
# individual probability of treatment values
cov = treat.prob # whatever the coverage of this MDA is
rho = comp.correlation # whatever the correlation of this MDA is
compliance.mat[,3] = initializePTreat(N = N, cov, rho) # initialize pTreat - correlation for each individual (mat[,2])
# record this value for previous coverage #
prevCov = cov # set prevCov to coverage value used
prevRho = rho # set prevRho to correlation value used
}
# subsequent MDA rounds
if (i %in% times.of.treat.in[-1]) {
if((prevCov != treat.prob) | (prevRho != comp.correlation)){
# 1) check and update/redraw any zero values introduced in pTreat for individuals since last MDA round
compliance.mat[,3] = checkForZeroPTreat(pTreat = compliance.mat[,2], prevCov, prevRho)
# 2) assign everyone a new/updated pTreat value for the next MDA round if cov and/or rho have changed
cov = treat.prob
rho = comp.correlation
compliance.mat[,3] = editPTreat(pTreat = compliance.mat[,3], cov, rho)
prevCov = cov
prevRho = rho
}
# check for zero pTreat values since last MDA regardless of whether new cov/rho values
compliance.mat[,3] = checkForZeroPTreat(pTreat = compliance.mat[,3], prevCov, prevRho)
}
# specify if individuals are to be treated in this round in compliance.mat (column 6)
eligible_out <- check_eligibility(comp.mat = compliance.mat, all.dt = all.mats.cur, minAgeMDA = 5, maxAgeMDA = 80)
compliance.mat <- eligible_out[[1]] # extract updated compliance matrix
cov.in <- compliance.mat[,6] # this is vector of individuals to be treated from compliance mat, to feed into change.worm.per.ind.treat
# Count the number of treated hosts
hostsEligibleAge <- compliance.mat[,4]
eligible_hosts <- eligible_out[[2]]
hostsTreated <- length(eligible_hosts)
CovEligibles = hostsTreated / hostsEligibleAge * 100
CovTotal = hostsTreated / N * 100
}
# ======================================================================================================= #
#         Update print output here with new coverage vals from compliance structure                       #
# update when no MDA round
if(isTRUE(print_progress) & (any(i == year_its)) & !any(i == times.of.treat.in))
{print(paste(round(i * DT, digits = 2), 'yrs;', (paste(round(i/time.its * 100, digits = 1), '%', sep=' '))))}
# # update when no MDA round
# if(isTRUE(print_progress) & (any(i == year_its + 1)) & any(i == times.of.treat.in))
# {print(paste(round(CovEligibles, digits = 3), '% coverage eligibles', paste(round(CovTotal, digits = 3), '% coverage total', sep=' ')))}
#sex and age dependent exposure, mean exposure must be 1, so ABR is meaningful
mls <- which(all.mats.cur[,3] == 1) # matt : ?
fmls <- which(all.mats.cur[,3] == 0) # matt: ?
s.a.exp <- rep(0, N)
s.a.exp[mls] <- m.exp * exp(-age.exp.m * (all.mats.cur[mls, 2]))
gam.m <- 1 / mean(s.a.exp[mls]) #normalize so mean = 1 (matt: is this equivalent to including the gamma_s term?)
s.a.exp[mls] <- s.a.exp[mls] * gam.m
s.a.exp[fmls] <- f.exp * exp(-age.exp.f * (all.mats.cur[fmls, 2]))
gam.f <- 1 / mean(s.a.exp[fmls]) #normalize so mean = 1
s.a.exp[fmls] <- s.a.exp[fmls] * gam.f
ex.vec <- ex.vec * (1 / mean(ex.vec)) #normalize so mean = 1 (matt: normalising the indvidual-specific exposure from line 565)
tot.ex.ai <- s.a.exp * ex.vec # matt: combine sex/age specific exposure + individual specific exposure (total exposure to blackfly bites)
tot.ex.ai <- tot.ex.ai * (1 / mean(tot.ex.ai)) #normalize so mean = 1
#increase age (for next time step)
all.mats.temp[,2] <- (all.mats.cur[,2]) + DT #increase age for all individuals
death.vec <- rbinom(N, 1, (1/mean.age) * DT) #select individuals to die
to.die <- which(death.vec == 1)
at.ab.max <- which(all.mats.temp[,2] >= real.max.age)
to.die <- c(to.die, at.ab.max)
to.die <- unique(to.die) #may have repeated indivudals i.e selected by binom and >80
##################
#delay calculations
##################
#there is a delay in new parasites entering humans (from fly bites) and entering the first adult worm age class
new.worms.m <- c()
new.worms.nf <- c()
new.worms.m <- rbinom(N, size = l.extras[,length(l.extras[1,])], prob = 0.5) #draw males and females from last column of delay matrix
new.worms.nf <- l.extras[,length(l.extras[1,])] - new.worms.m
#move individuals along
l.extras[,inds.l.mat] <- l.extras[,(inds.l.mat-1)]
#mean number of L3 in fly population
L3.in <- mean(all.mats.cur[, 6])
# change m based on ABR change due to vector control if called (during vector control duration iteration period)
if(!is.na(vector.control.strt)){
if (i >= vc.iter.strt && i < vc.iter.stp) {
ABR_updated <- ABR - (ABR * vector.control.efficacy) # proportional reduction in ABR (x efficacy) during VC
m = ABR_updated * ((1/104) / 0.63) # update m
}
}
# change m back to original after VC finishes (can change when this occurs i.e, one year after VC ends)
if(!is.na(vector.control.strt)){
if (i >= vc.iter.stp) {
m = ABR * ((1/104) / 0.63) # update m
}
}
# to track #
if (!is.na(vector.control.strt) && i >= vc.iter.strt && i < vc.iter.stp) {
ABR_upd <- ABR_updated
} else {
ABR_upd <- ABR
}
#rate of infections in humans
#delta.hz, delta.hinf, c.h are density dependence parameters, expos is the exposure of each person to bites
nw.rate <- Wplus1.rate(delta.hz, delta.hinf, c.h, L3 = L3.in, m ,
beta, expos = tot.ex.ai, DT)
new.worms <- rpois(N, nw.rate) #total new establishing L3 for each individual
l.extras[,1] <- new.worms
for(k in 1 : num.comps.worm) #go through each adult worm compartment
{
if(k == 1) {from.last <- rep(0, N)} #create vector for worms coming from previous compartment (needs to be 0 when k ==1)
res.w1 <- change.worm.per.ind1(treat.vec = treat.vec.in, lambda.zero = lambda.zero, DT = DT, omeg = omeg,
ws = worms.start, compartment = k, total.dat = all.mats.cur, mort.rates = mort.rates.worms,
time.each.comp = time.each.comp.worms, new.worms.m = new.worms.m, w.f.l.c = from.last,
num.comps = num.comps.worm)
res.w.treat <- change.worm.per.ind.treat(give.treat = give.treat, iteration = i, treat.start = treat.start,
times.of.treat = times.of.treat.in, treat.stop = treat.stop,
onchosim.cov = cov.in, treat.vec = treat.vec.in, DT = DT, cum.infer = cum.infer,
lam.m = lam.m, phi = phi, N = res.w1[[3]], mort.fems = res.w1[[2]], lambda.zero.in = res.w1[[1]])
res.w2 <- change.worm.per.ind2(DT = DT, time.each.comp = time.each.comp.worms, compartment = k, new.worms.nf.fo = new.worms.nf, w.f.l.c = from.last,
N = res.w1[[3]], cur.Wm.nf = res.w1[[4]], mort.fems = res.w.treat[[3]], cur.Wm.f = res.w1[[5]], omeg = res.w1[[7]],
male.tot.worms = res.w1[[8]], worm.loss.males = res.w1[[9]],
lambda.zero.in = res.w.treat[[1]], treat.vec = res.w.treat[[2]])
res <- res.w2 # (matt: re-label the final result output to res so do not have to change res below)
from.last <- res # (matt: re-label the final result output to res so do not have to change res below)
# from.last <- res #assign output to use at next iteration, indexes 2, 5, 6 (worms moving through compartments)
# update male worms in matrix for compartment k
all.mats.temp[, (6 + num.mf.comps + k)] <- res[[1]]
# update females worms in matrix
all.mats.temp[, (6 + num.mf.comps + num.comps.worm + k)] <- res[[3]] # infertile, num.comps.worm skips over males
all.mats.temp[, (6 + num.mf.comps + 2*num.comps.worm + k)] <- res[[4]] # fertile, num.comps.worm skips over males and infertile females
}
if(give.treat == 1 & i >= treat.start) {treat.vec.in <- res[[7]]} #treated individuals
for(mf.c in 1 : num.mf.comps)
{
res.mf <- change.micro(dat = all.mats.cur, num.comps =num.comps.worm, mf.cpt = mf.c,
num.mf.comps = num.mf.comps, ws=worms.start, DT=DT, time.each.comp = time.each.comp.mf,
mu.rates.mf = mort.rates.mf, fec.rates = fec.rates.worms, mf.move.rate = mf.move.rate, up = up, kap = kap, iteration = i,
treat.vec = treat.vec.in, give.treat = give.treat, treat.start = treat.start)
all.mats.temp[, 6 + mf.c] <- res.mf
}
#inputs for delay in L1
exp.delay.temp <- exposure.delay[, length(exposure.delay[1,])]
mf.delay.temp <- mf.delay[, length(mf.delay[1,])]
l1.delay.temp <- l1.delay #L1 from previous timestep
#move values along
exposure.delay[, inds.exp.mats] <- exposure.delay[, (inds.exp.mats -1)]
mf.delay[, inds.mfd.mats] <- mf.delay[, (inds.mfd.mats - 1)]
#update L1, L2 and L3
#total number of mf in each person
mf.temp <- rowSums(all.mats.cur[, 7 : (6 + num.mf.comps)]) #sum mf over compartments, mf start in column 7
all.mats.temp[, 4] <- calc.L1(beta, mf = mf.temp, mf.delay.in = mf.delay.temp, expos = tot.ex.ai, delta.vo, c.v, nuone, mu.v, a.v, expos.delay = exp.delay.temp)
all.mats.temp[, 5] <- calc.L2(nuone, L1.in = l1.delay.temp, mu.v, nutwo, mf = mf.delay.temp, a.v, expos = exp.delay.temp)
all.mats.temp[, 6] <- calc.L3(nutwo, L2.in = all.mats.cur[, 5], a.H, g, mu.v, sigma.L0)
#new values for delay parts
l1.delay <- all.mats.temp[, 4]
mf.delay[, 1] <- rowSums(all.mats.cur[, 7 : (6 + num.mf.comps)])
exposure.delay[, 1] <- tot.ex.ai
#===========================#
#     OAE module funcs      #
if(epilepsy_module == "YES"){
if(i == 1){
OAE_out1 <- find_indiv_OAE_func(dat = all.mats.temp, mf.start = mf.start, mf.end = mf.end, worms.start = worms.start, nfw.start = nfw.start, fw.end = fw.end,
infected_at_all = infected_at_all, age_to_samp = age_to_samp, OAE = OAE, tested_OAE = tested_OAE, check_ind = check_ind) # step 1
infected_at_all = OAE_out1[[2]] # updated (when i = 1)
check_ind = OAE_out1[[3]] # updated (when i = 1)
temp.mf <- mf.per.skin.snip(ss.wt = 2, num.ss = 2, slope.kmf = 0.0478, int.kMf = 0.313, data = all.mats.temp, nfw.start, fw.end,
mf.start, mf.end, pop.size = N, kM.const.toggle)
OAE_out2 <- new_OAE_cases_func(temp.mf = temp.mf, tot_ind_ep_samp = OAE_out1[[1]], OAE_probs = OAE_probs, dat = all.mats.temp,
OAE = OAE, tested_OAE = tested_OAE,
prev_OAE = prev_OAE, OAE_incidence_DT = OAE_incidence_DT,
OAE_incidence_DT_under_5 = OAE_incidence_DT_under_5, OAE_incidence_DT_5_10 = OAE_incidence_DT_5_10, OAE_incidence_DT_11_15 = OAE_incidence_DT_11_15,
OAE_incidence_DT_M = OAE_incidence_DT_M, OAE_incidence_DT_F = OAE_incidence_DT_F) # step 2
OAE = OAE_out2[[9]] # updated (when i = 1)
tested_OAE = OAE_out2[[10]] # updated (when i = 1)
}
if(i > 1){
OAE_out1 <- find_indiv_OAE_func(dat = all.mats.temp, mf.start = mf.start, mf.end = mf.end, worms.start = worms.start, nfw.start = nfw.start, fw.end = fw.end,
infected_at_all = infected_at_all, age_to_samp = age_to_samp, OAE = OAE, tested_OAE = tested_OAE, check_ind = check_ind) # step 1
infected_at_all = OAE_out1[[2]] # updated (when i > 1)
check_ind = OAE_out1[[3]] # updated (when i > 1)
temp.mf <- mf.per.skin.snip(ss.wt = 2, num.ss = 2, slope.kmf = 0.0478, int.kMf = 0.313, data = all.mats.temp, nfw.start, fw.end,
mf.start, mf.end, pop.size = N, kM.const.toggle)
OAE_out2 <- new_OAE_cases_func(temp.mf = temp.mf, tot_ind_ep_samp = OAE_out1[[1]], OAE_probs = OAE_probs, dat = all.mats.temp,
OAE = OAE, tested_OAE = tested_OAE,
prev_OAE = OAE_out2[[1]], OAE_incidence_DT = OAE_out2[[2]],
OAE_incidence_DT_under_5 = OAE_out2[[3]], OAE_incidence_DT_5_10 = OAE_out2[[4]], OAE_incidence_DT_11_15 = OAE_out2[[5]],
OAE_incidence_DT_M = OAE_out2[[6]], OAE_incidence_DT_F = OAE_out2[[7]]) # step 2
OAE = OAE_out2[[9]] # updated (when i > 1)
tested_OAE = OAE_out2[[10]] # updated (when i > 1)
}
}
#save prevalence at current timestep
temp.mf <- mf.per.skin.snip(ss.wt = 2, num.ss = 2, slope.kmf = 0.0478, int.kMf = 0.313, data = all.mats.temp, nfw.start, fw.end,
mf.start, mf.end, pop.size = N, kM.const.toggle)
prev <-  c(prev, prevalence.for.age(age = min.mont.age, ss.in = temp.mf, main.dat = all.mats.temp))
mean.mf.per.snip <- c(mean.mf.per.snip, mean(temp.mf[[2]][which(all.mats.temp[,2] >= min.mont.age)]))
mf.per.skin.snp.out <- temp.mf[[2]] #to extract out mf per skin snip for each individual?
L3_vec <- c(L3_vec, mean(all.mats.temp[, 6]))
ABR_recorded <- c(ABR_recorded, ABR_upd) # tracking changing ABR
coverage.recorded <- c(coverage.recorded, coverage.upd) # track changing coverage if specified
# new individual exposure for newborns, clear rows for new borns
if(length(to.die) > 0)
{
ex.vec[to.die] <- rgamma(length(to.die), gam.dis, gam.dis)
l.extras[to.die, ] <- 0 #establishing adult worms
mf.delay[to.die, 1] <- 0 #individual dies so no contribution to L1s at this timestep
l1.delay[to.die] <- 0
treat.vec.in[to.die] <- NA
all.mats.temp[to.die, cols.to.zero] <- 0 #set age, sex and parasites to 0 (includes L1, but not L2 L3)
all.mats.temp[to.die, 3] <- rbinom(length(to.die), 1, 0.5) #draw sex
if(epilepsy_module == "YES"){
infected_at_all[to.die] <- 0 # index those individuals to die as no longer ever infected
age_to_samp[to.die] <- sample(seq(3, 15, DT), size = length(to.die), replace = TRUE) # for those individuals set to die, resample
OAE[to.die] <-  0 # index those individuals to die as no longer with OAE
tested_OAE[to.die] <-  0 # index those individuals to die as no longer tested
}
}
i <- i + 1
}
if(epilepsy_module == "YES"){
# return(list(all.mats.temp, prev, mean.mf.per.snip, mf.per.skin.snp.out, OAE, prev_OAE = OAE_out2[[1]], check_ind = OAE_out1[[3]],
#             OAE_incidence_DT = OAE_out2[[2]], OAE_incidence_DT_3_5 = OAE_out2[[3]], OAE_incidence_DT_5_10 = OAE_out2[[4]],
#             OAE_incidence_DT_M = OAE_out2[[5]], OAE_incidence_DT_F = OAE_out2[[6]])) #[[2]] is mf prevalence, [[3]] is intensity
if(isTRUE(run_equilibrium)){
outp <- (list(prev, mean.mf.per.snip, L3_vec,
list(all.mats.temp, ex.vec, treat.vec.in, l.extras, mf.delay, l1.delay, ABR, exposure.delay),
prev_OAE = OAE_out2[[1]], OAE_incidence_DT = OAE_out2[[2]],
OAE_incidence_DT_under_5 = OAE_out2[[3]], OAE_incidence_DT_5_10 = OAE_out2[[4]], OAE_incidence_DT_11_15 = OAE_out2[[5]],
OAE_incidence_DT_M = OAE_out2[[6]], OAE_incidence_DT_F = OAE_out2[[7]],
list(OAE = OAE, age_to_samp = age_to_samp, tested_OAE = tested_OAE, infected_at_all = infected_at_all,
check_ind = OAE_out1[[3]], tot_ind_ep_samp = OAE_out1[[1]], OAE_probs = OAE_probs),
ABR_recorded, coverage.recorded))
names(outp) <- c('mf_prev', 'mf_intens', 'L3', 'all_equilibrium_outputs', 'OAE_prev','OAE_incidence',
'OAE_incidence_under_5yrs','OAE_incidence_5_10yrs','OAE_incidence_10_15yrs',
'OAE_incidence_males','OAE_incidence_females','all_OAE_equilibirum_ouputs',
'ABR_recorded', 'coverage.recorded')
return(outp)
}
if(isFALSE(run_equilibrium))
{
outp <- (list(prev, mean.mf.per.snip, L3_vec, ABR, all.mats.temp,
prev_OAE = OAE_out2[[1]], OAE_incidence_DT = OAE_out2[[2]],
OAE_incidence_DT_under_5 = OAE_out2[[3]], OAE_incidence_DT_5_10 = OAE_out2[[4]], OAE_incidence_DT_11_15 = OAE_out2[[5]],
OAE_incidence_DT_M = OAE_out2[[6]], OAE_incidence_DT_F = OAE_out2[[7]],
list(OAE = OAE, age_to_samp = age_to_samp, tested_OAE = tested_OAE, infected_at_all = infected_at_all,
check_ind = OAE_out1[[3]], tot_ind_ep_samp = OAE_out1[[1]], OAE_probs = OAE_probs),
ABR_recorded, coverage.recorded))
names(outp) <- c('mf_prev', 'mf_intens', 'L3', 'ABR','all_equilibrium_outputs', 'OAE_prev','OAE_incidence',
'OAE_incidence_under_5yrs','OAE_incidence_5_10yrs','OAE_incidence_10_15yrs',
'OAE_incidence_males','OAE_incidence_females','all_OAE_equilibirum_ouputs',
'ABR_recorded', 'coverage.recorded')
return(outp)
}
} else {
# ================================#
#  When epilpsy module not called #
#enough outputs to restart sims
if(isTRUE(run_equilibrium))
{
outp <- list(prev, mean.mf.per.snip, L3_vec, list(all.mats.temp, ex.vec, treat.vec.in, l.extras, mf.delay, l1.delay, ABR, exposure.delay), ABR_recorded, coverage.recorded)
names(outp) <- c('mf_prev', 'mf_intens', 'L3', 'all_equilibrium_outputs', 'ABR_recorded', 'coverage.recorded')
return(outp)
}
#assuming output will not be used for further sims
if(isFALSE(run_equilibrium))
{
outp <- list(prev, mean.mf.per.snip, L3_vec, ABR, all.mats.temp, ABR_recorded, coverage.recorded)
names(outp) <-  c('mf_prev', 'mf_intens', 'L3', 'ABR', 'all_infection_burdens', 'ABR_recorded', 'coverage.recorded')
return(outp)
}
}
}
# ===================================================================================================================== #
#                 CODE BELOW TO SPECIFY RUNS ON CLUSTER/ CALL EP.EQUI.FUNC TO RUN CODE ABOVE                            #
# ===================================================================================================================== #
# devtools::load_all() # testing
# ====== #
# set-up #
# ====== #
equilbirium_yrs <- 50
treatment_history_yrs <- 15
treatment_scenario_yrs <- 25
total_yrs <- equilbirium_yrs + treatment_history_yrs + treatment_scenario_yrs
# treatment start
treat.strt.short = 60 # history (short MDA of 5 years)
# treatment stop (all scenarios)
treat.stp = 90
# other treatment parameters
give.treat.in = 1
trt.int = 1 # will need to change when looking at switch from annual to biannual
# ============== #
# need histories #
# treat.naive.An.IVM # no switching needed so dont need to call this/ use as an input
# correlation par #
cor.low <- 0.1
cor.low.seq <- rep(cor.low, 1200)
cor.mid <- 0.5
cor.mid.seq <- rep(cor.mid, 1200)
cor.high <- 0.9
cor.high.seq <- rep(cor.high, 1200)
# SNA par #
sna.seq <- c(rep(0.05, 600), rep(0.1, 600))
# ABR (endemicity) par: 294 (30% mf prev, hypo), 607 (50% mf prev, meso), 2297 (70% mf prev, hyper) #
abr.seq <- c(rep(294, 200), rep(607, 200), rep(2297, 200), rep(294, 200), rep(607, 200), rep(2297, 200))
# make dataframe for first combo naive + aIVM + corr.pars + SNA pars + endemicity #
df.naive.aIVM.rholow <- data.frame(rho.in = cor.low.seq, sna.in = sna.seq, abr.in = abr.seq)
df.naive.aIVM.rholow$label <- as.factor("short + aIVM")
df.naive.aIVM.rhomid <- data.frame(rho.in = cor.mid.seq, sna.in = sna.seq, abr.in = abr.seq)
df.naive.aIVM.rhomid$label <- as.factor("short + aIVM")
df.naive.aIVM.rhohigh <- data.frame(rho.in = cor.high.seq, sna.in = sna.seq, abr.in = abr.seq)
df.naive.aIVM.rhohigh$label <- as.factor("short + aIVM")
df.naive.aIVM <- rbind(df.naive.aIVM.rholow, df.naive.aIVM.rhomid, df.naive.aIVM.rhohigh)
tot_parms <- df.naive.aIVM
# make vector of number of iters/draws repeating for total combination of pars
n_iters <- 200
no_repeats_tot <- nrow(tot_parms)/ n_iters
inds_reps <- rep(c(1:200), times = no_repeats_tot)
tot_parms$iter <- inds_reps
output <- ep.equi.sim(time.its = total_yrs,
ABR = 2297, # hyper
N.in = 440,
treat.timing = NA, # need to change for biannual switch
treat.int = trt.int, # remove for biannual switch
treat.prob = 0.65,
treat.prob.variable = NA,
give.treat = give.treat.in,
treat.start = treat.strt.naive,
treat.stop = treat.stp,
pnc = 0.05,
min.mont.age = 5,
vector.control.strt = NA, # not in these histories
delta.hz.in = 0.186,
delta.hinf.in = 0.003,
c.h.in = 0.005,
gam.dis.in = 0.3,
run_equilibrium = TRUE,
equilibrium = NA,
print_progress = TRUE,
correlated_compliance = "YES",
comp.correlation = 0.1, # near-random compliance
treat.switch = NA,
treat.type = NA)
output <- ep.equi.sim(time.its = total_yrs,
ABR = 2297, # hyper
N.in = 440,
treat.timing = NA, # need to change for biannual switch
treat.int = trt.int, # remove for biannual switch
treat.prob = 0.65,
treat.prob.variable = NA,
give.treat = give.treat.in,
treat.start = treat.strt.short,
treat.stop = treat.stp,
pnc = 0.05,
min.mont.age = 5,
vector.control.strt = NA, # not in these histories
delta.hz.in = 0.186,
delta.hinf.in = 0.003,
c.h.in = 0.005,
gam.dis.in = 0.3,
run_equilibrium = TRUE,
equilibrium = NA,
print_progress = TRUE,
correlated_compliance = "YES",
comp.correlation = 0.1, # near-random compliance
treat.switch = NA,
treat.type = NA)
# names(output)
#
# tme <- seq(1, 90*366-1)/366
tme <- seq(1, 90*732-1)/732 # for MOX (1/2 day dt)
plot(tme, output$mf_prev, type = 'l', xlab = 'time (years)', ylab = 'microfilarial prevalence', ylim = c(0, 1))
#
plot(tme, output$mf_prev, type = 'l', xlab = 'time (years)', ylab = 'microfilarial prevalence', ylim = c(0, 0.4), xlim = c(50,90))
#
plot(tme, output$mf_prev, type = 'l', xlab = 'time (years)', ylab = 'microfilarial prevalence', ylim = c(0, 0.7), xlim = c(50,90))
combinations_count <- table(tot_parms$rho.in, tot_parms$sna.in, tot_parms$abr.in)
combinations_count
View(tot_parms)
# ================================================================================== #
# to work out length of each run (this should be the same as the epi script inputs)
DT.in <- 1/366 #timestep must be one day
treat.len <- 25 #treatment duration in years
treat.strt  = round(80 / (DT.in ))
treat.stp = treat.strt + round(treat.len / (DT.in )) #treatment start and stop
timesteps = treat.stp + round(10 / (DT.in )) #final duration (10 here is 10 years after treatment stops to run model)
# note if not treatment, then this number is total model run time!
# ========================================================== #
# specify certain objects for loop (not previously specified)
model_its <- timesteps - 1 # this should be number of timesteps (length of model output)
repeats   <- 200 # this should be number of times repeat a par combo (e.g., 100)
number_repeats <- 200 # or this ? (same as repeats)
# ========================================================= #
# repeat this text from the epi script (to get number of iters for parameter combos)
# do this for each intervention coverage (or the first parameter) #
# 65% coverage #
# 1) specify vector of parameter values to test & vector for iterations/repeats  #
# calculate abr x k_E (below) for each intervention coverage (so times 2)
# abr30 <- c(403, 293, 274) # ABR to get 30% prevalence for k_E 0.2, 0.3, 0.4
# abr50 <- c(1602, 750, 560) # ABR to get 50% prevalence for k_E 0.2, 0.3, 0.4
# abr60 <- c(4480, 1499, 898) # ABR to get 60% prevalence for k_E 0.2, 0.3, 0.4
# abr70 <- c(16870, 3473, 1749) # ABR to get 70% prevalence for k_E 0.2, 0.3, 0.4
# abr <- c(abr30, abr50, abr60, abr70)
#
# num_repeats_each_ABR <- 130 # number of times repeat each ABR input
# tot_abr <- rep(abr, each = num_repeats_each_ABR) # vector of all ABR values to test
# k_e <- c(0.2, 0.3, 0.4) # 3rd par
# num_par_combos <- length(abr) * length(k_e) # number of combos to make ind_rep
# inds_reps <- rep(seq(1, num_repeats_each_ABR), num_par_combos) # 2) specify number of TOTAL iterations required: number of repeats for each ABR ( 1- 3), with 4 combos (ABR x k_e pars)  #
# so this is (indice repeating sequence length of total number of iters)
# calculate abr x k_E (below) for each intervention coverage (so time 2)
abr30 <- c(403, 293, 274) # ABR to get 30% prevalence for k_E 0.2, 0.3, 0.4
abr50 <- c(1602, 750, 560) # ABR to get 50% prevalence for k_E 0.2, 0.3, 0.4
abr60 <- c(4480, 1499, 898) # ABR to get 60% prevalence for k_E 0.2, 0.3, 0.4
abr70 <- c(16870, 3473, 1749) # ABR to get 70% prevalence for k_E 0.2, 0.3, 0.4
abr <- c(abr30, abr50, abr60, abr70)
num_repeats_each_ABR <- 200 # number of times repeat each ABR input
tot_abr <- rep(abr, each = num_repeats_each_ABR) # vector of all ABR values to test
k_e <- c(0.2, 0.3, 0.4) # 3rd par
k_e_vec <- c(k_e, k_e, k_e, k_e)  # vector to repeat k_e sequence (to match relevant abrs)
tot_k_e <- rep(k_e_vec, each = num_repeats_each_ABR)
inds_reps <- rep(seq(1, num_repeats_each_ABR), length(tot_abr)/num_repeats_each_ABR) # repeating sequence of 1: num repeats, number of combo times
#inds_reps2 <- c(inds_reps, inds_reps) # need to multiply number of iterations x 2 (since doing two types intervention sims)
tot_parms <- as.data.frame(cbind(abr = tot_abr, k_e = tot_k_e))
tot_parms2 <- unique(tot_parms[,c('abr','k_e')])
tot_parms2$mf_prev <- c('mf_prev_30', 'mf_prev_30', 'mf_prev_30',
'mf_prev_50', 'mf_prev_50', 'mf_prev_50',
'mf_prev_60', 'mf_prev_60', 'mf_prev_60',
'mf_prev_70', 'mf_prev_70', 'mf_prev_70')
View(tot_parms2)
abr <- as.data.frame(tot_parms2$abr)
abr
View(tot_parms2)
temp_mat <- matrix(NA, nrow = model_its, ncol = repeats)
View(temp_mat)
dim(temp_mat)
abr <- tot_parms2$abr[i]
abr <- tot_parms2$abr[1]
View(tot_parms2)
matrix_empty = matrix(nrow = model_its, ncol = nrow(tot_parms2))
dim(matrix_empty)
