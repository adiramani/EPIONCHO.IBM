alpha = cov * (1 - rho) / rho
beta = (1 - cov) * (1 - rho) / rho
# Draw N probabilities from the beta distribution
pTreat = rbeta(N, alpha, beta)
# Return the generated pTreat values
return(pTreat)
}
checkForZeroPTreat <- function(pTreat, cov, rho) {
# Find indices where pTreat values are zero
zeros <- (pTreat == 0)
# If there are any zero values, regenerate them using the beta distribution
if (any(zeros)) {
# Calculate alpha and beta parameters for the beta distribution
alpha = cov * (1 - rho) / rho
beta = (1 - cov) * (1 - rho) / rho
# Generate new pTreat values only for the zero positions
pTreat[zeros] = rbeta(sum(zeros), alpha, beta)
}
# Return the updated pTreat vector
return(pTreat)
}
editPTreat <- function(pTreat, cov, rho) {
# Define the parameters for the probability of treatment
alpha <- cov * (1 - rho) / rho
beta <- (1 - cov) * (1 - rho) / rho
# Get the number of elements in pTreat
N = length(pTreat)
# Draw new probabilities from the beta distribution and sort them
newPTreats <- sort(rbeta(N, alpha, beta))
# Rank the original pTreat values to get indices for sorting
indices <- rank(pTreat)
# Assign the values from newPTreats to the appropriate places in pTreat vector
pTreat <- newPTreats[indices]
return(pTreat)
}
length(compliance.mat[,1])
# Number of random numbers you want to generate
n <- 366
# Generate random numbers between 0 and 1 with a timestep of 1/366
random_numbers <- runif(n, min = 0, max = 1)
# Scale the random numbers to the range 0 to 80
scaled_numbers <- random_numbers * 80
# Number of random numbers you want to generate
n <- 440
# Generate a sequence from 0 to 1 with 1/366 increments
sequence <- seq(0, 1, by = 1/366)
# Scale the sequence to the range 0 to 80
scaled_numbers <- sequence * 80
scaled_numbers
# Number of random numbers you want to generate
n <- 440
# Generate random integers between 0 and 365
random_integers <- sample(0:366, n, replace = TRUE)
# Scale the random integers to the range [0, 1]
random_numbers <- random_integers / 366
# Scale the random numbers to the range [0, 80]
scaled_numbers <- random_numbers * 80
scaled_numbers
# set up current age for eligibility criteria check for MDA
compliance.mat[,1] <- scaled_numbers
View(compliance.mat)
N = 440
probneverTreat = 0.1
coverage = 0.6
correlation = 0.2
compliance.mat <- matrix(nrow=N, ncol=4) # col 1 = age, col 2 = never_treat,
# col 3 = probability of treatment, col 4 = to be treated in this round
compliance.mat[,2] = generateNeverTreat(N, probneverTreat) # never treat col (mat[,2])
# individual probability of treatment values
cov = coverage # whatever the coverage of this MDA is
rho = correlation # whatever the correlation of this MDA is
compliance.mat[,3] = initializePTreat(N, cov, rho) # initialize pTreat - correlation for each individual (mat[,3])
# previous coverage #
prevCov = cov # set prevCov to coverage value used
prevRho = rho # set prevRho to correlation value used
# ========================================== #
# at each subsequent MDA (associated iter i) #
# logic if cov or rho updated for next MDA round
#if((prevCov != coverage) | (prevRho != correlation)){
# 1) check and update/redraw any zero values introduced in pTreat for individuals since last MDA round
#compliance.mat[20,2] = 0 # test = introduce 1 zero at p20 in pTreat (compliance[,3])
compliance.mat[,3] = checkForZeroPTreat(pTreat = compliance.mat[,3], prevCov, prevRho)
# 2) assign everyone a new/updated pTreat value for the next MDA round if cov and/or rho have changed
cov = coverage
rho = correlation
compliance.mat[,3] = editPTreat(pTreat = compliance.mat[,3], cov = 0.75, rho) # update pTreat = test with coverage going up to 0.75
prevCov = cov
prevRho = rho
#}
View(compliance.mat)
compliance.mat[,1] <- scaled_numbers
View(compliance.mat)
# Identify hosts in correct age range
hostsEligibleAge <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
hostsEligibleAge
View(compliance.mat)
# Generate all random numbers at once
random_numbers <- runif(length(compliance.mat[,1]))
random_numbers
View(compliance.mat)
# Find indices of hosts meeting conditions
#eligible_hosts <- which((hostsEligibleAge) & (random_numbers < pTreat) & (neverTreat == 0))
compliance.mat[,4] <- which((hostsEligibleAge) & (random_numbers < compliance.mat[,3]) & (compliance.mat[,2] == 0))
N = 440
probneverTreat = 0.1
coverage = 0.6
correlation = 0.2
compliance.mat <- matrix(nrow=N, ncol=6) # col 1 = age, col 2 = never_treat,
# col 3 = probability of treatment, col 4 = to be treated in this round
compliance.mat[,2] = generateNeverTreat(N, probneverTreat) # never treat col (mat[,2])
# individual probability of treatment values
cov = coverage # whatever the coverage of this MDA is
rho = correlation # whatever the correlation of this MDA is
compliance.mat[,3] = initializePTreat(N, cov, rho) # initialize pTreat - correlation for each individual (mat[,3])
# previous coverage #
prevCov = cov # set prevCov to coverage value used
prevRho = rho # set prevRho to correlation value used
View(compliance.mat)
compliance.mat[,1] <- scaled_numbers
View(compliance.mat)
compliance.mat[,4] <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
View(compliance.mat)
# Identify hosts in correct age range (hostsEligibleAge)
#hostsEligibleAge <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
#compliance.mat[,4] <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
compliance.mat[,4] <- (compliance.mat[,1] >= minAgeMDA) & (compliance.mat[,1] < maxAgeMDA)
hostsEligibleAge <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
View(compliance.mat)
View(compliance.mat)
# Generate all random numbers at once
#random_numbers <- runif(length(compliance.mat[,1]))
compliance.mat[,5] <- runif(length(compliance.mat[,1]))
View(compliance.mat)
# Find indices of hosts meeting conditions
#eligible_hosts <- which((hostsEligibleAge) & (random_numbers < pTreat) & (neverTreat == 0))
compliance.mat[,6] <- which((compliance.mat[,4] == 1) & (compliance.mat[,5] < compliance.mat[,3]) & (compliance.mat[,2] == 0))
# Find indices of hosts meeting conditions
#eligible_hosts <- which((hostsEligibleAge) & (random_numbers < pTreat) & (neverTreat == 0))
compliance.mat[,6] <- ifelse(compliance.mat[,4] == 1 & compliance.mat[,5] < compliance.mat[,3] & compliance.mat[,2] == 0, 1, 0)
View(compliance.mat)
sum(compliance.mat[,6])
238/440
N = 440
probneverTreat = 0.1
coverage = 0.6
correlation = 0.2
compliance.mat <- matrix(nrow=N, ncol=6) # col 1 = age, col 2 = never_treat,
# col 3 = probability of treatment, col 4 = to be treated in this round
compliance.mat[,2] = generateNeverTreat(N, probneverTreat) # never treat col (mat[,2])
generateNeverTreat <- function(N, probNeverTreat){
return(rbinom(N, size = 1, prob = probNeverTreat))
}
initializePTreat <- function(N, cov, rho) {
# Calculate alpha and beta parameters for the beta distribution
alpha = cov * (1 - rho) / rho
beta = (1 - cov) * (1 - rho) / rho
# Draw N probabilities from the beta distribution
pTreat = rbeta(N, alpha, beta)
# Return the generated pTreat values
return(pTreat)
}
checkForZeroPTreat <- function(pTreat, cov, rho) {
# Find indices where pTreat values are zero
zeros <- (pTreat == 0)
# If there are any zero values, regenerate them using the beta distribution
if (any(zeros)) {
# Calculate alpha and beta parameters for the beta distribution
alpha = cov * (1 - rho) / rho
beta = (1 - cov) * (1 - rho) / rho
# Generate new pTreat values only for the zero positions
pTreat[zeros] = rbeta(sum(zeros), alpha, beta)
}
# Return the updated pTreat vector
return(pTreat)
}
editPTreat <- function(pTreat, cov, rho) {
# Define the parameters for the probability of treatment
alpha <- cov * (1 - rho) / rho
beta <- (1 - cov) * (1 - rho) / rho
# Get the number of elements in pTreat
N = length(pTreat)
# Draw new probabilities from the beta distribution and sort them
newPTreats <- sort(rbeta(N, alpha, beta))
# Rank the original pTreat values to get indices for sorting
indices <- rank(pTreat)
# Assign the values from newPTreats to the appropriate places in pTreat vector
pTreat <- newPTreats[indices]
return(pTreat)
}
N = 440
probneverTreat = 0
coverage = 0.6
correlation = 0.2
compliance.mat <- matrix(nrow=N, ncol=6) # col 1 = age, col 2 = never_treat,
# col 3 = probability of treatment, col 4 = to be treated in this round
compliance.mat[,2] = generateNeverTreat(N, probneverTreat) # never treat col (mat[,2])
# individual probability of treatment values
cov = coverage # whatever the coverage of this MDA is
rho = correlation # whatever the correlation of this MDA is
compliance.mat[,3] = initializePTreat(N, cov, rho) # initialize pTreat - correlation for each individual (mat[,3])
# previous coverage #
prevCov = cov # set prevCov to coverage value used
prevRho = rho # set prevRho to correlation value used
n <- 440 # Number of random numbers you want to generate
random_integers <- sample(0:366, n, replace = TRUE) # Generate random integers between 0 and 365
random_numbers <- random_integers / 366 # Scale the random integers to the range [0, 1]
scaled_numbers <- random_numbers * 80 # Scale the random numbers to the range [0, 80]
compliance.mat[,1] <- scaled_numbers
compliance.mat[,4] <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
# Generate all random numbers at once
#random_numbers <- runif(length(compliance.mat[,1]))
compliance.mat[,5] <- runif(length(compliance.mat[,1]))
# Find indices of hosts meeting conditions
#eligible_hosts <- which((hostsEligibleAge) & (random_numbers < pTreat) & (neverTreat == 0))
compliance.mat[,6] <- ifelse(compliance.mat[,4] == 1 & compliance.mat[,5] < compliance.mat[,3] & compliance.mat[,2] == 0, 1, 0)
sum(compliance.mat)/440
sum(compliance.mat[,6])/440
generateNeverTreat <- function(N, probNeverTreat){
return(rbinom(N, size = 1, prob = probNeverTreat))
}
initializePTreat <- function(N, cov, rho) {
# Calculate alpha and beta parameters for the beta distribution
alpha = cov * (1 - rho) / rho
beta = (1 - cov) * (1 - rho) / rho
# Draw N probabilities from the beta distribution
pTreat = rbeta(N, alpha, beta)
# Return the generated pTreat values
return(pTreat)
}
checkForZeroPTreat <- function(pTreat, cov, rho) {
# Find indices where pTreat values are zero
zeros <- (pTreat == 0)
# If there are any zero values, regenerate them using the beta distribution
if (any(zeros)) {
# Calculate alpha and beta parameters for the beta distribution
alpha = cov * (1 - rho) / rho
beta = (1 - cov) * (1 - rho) / rho
# Generate new pTreat values only for the zero positions
pTreat[zeros] = rbeta(sum(zeros), alpha, beta)
}
# Return the updated pTreat vector
return(pTreat)
}
editPTreat <- function(pTreat, cov, rho) {
# Define the parameters for the probability of treatment
alpha <- cov * (1 - rho) / rho
beta <- (1 - cov) * (1 - rho) / rho
# Get the number of elements in pTreat
N = length(pTreat)
# Draw new probabilities from the beta distribution and sort them
newPTreats <- sort(rbeta(N, alpha, beta))
# Rank the original pTreat values to get indices for sorting
indices <- rank(pTreat)
# Assign the values from newPTreats to the appropriate places in pTreat vector
pTreat <- newPTreats[indices]
return(pTreat)
}
# generate randome ages between 0 and 80 to test func below
n <- 440 # Number of random numbers you want to generate
random_integers <- sample(0:366, n, replace = TRUE) # Generate random integers between 0 and 365
random_numbers <- random_integers / 366 # Scale the random integers to the range [0, 1]
scaled_numbers <- random_numbers * 80 # Scale the random numbers to the range [0, 80]
N = 440
probneverTreat = 0
coverage = 0.6
correlation = 0.2
compliance.mat <- matrix(nrow=N, ncol=6) # col 1 = age, col 2 = never_treat,
# col 3 = probability of treatment, col 4 = to be treated in this round
compliance.mat[,2] = generateNeverTreat(N, probneverTreat) # never treat col (mat[,2])
# individual probability of treatment values
cov = coverage # whatever the coverage of this MDA is
rho = correlation # whatever the correlation of this MDA is
compliance.mat[,3] = initializePTreat(N, cov, rho) # initialize pTreat - correlation for each individual (mat[,3])
# previous coverage #
prevCov = cov # set prevCov to coverage value used
prevRho = rho # set prevRho to correlation value used
# ========================================== #
# at each subsequent MDA (associated iter i) #
# logic if cov or rho updated for next MDA round
#if((prevCov != coverage) | (prevRho != correlation)){
# 1) check and update/redraw any zero values introduced in pTreat for individuals since last MDA round
#compliance.mat[20,2] = 0 # test = introduce 1 zero at p20 in pTreat (compliance[,3])
compliance.mat[,3] = checkForZeroPTreat(pTreat = compliance.mat[,3], prevCov, prevRho)
# 2) assign everyone a new/updated pTreat value for the next MDA round if cov and/or rho have changed
cov = coverage
rho = correlation
compliance.mat[,3] = editPTreat(pTreat = compliance.mat[,3], cov = 0.75, rho) # update pTreat = test with coverage going up to 0.75
prevCov = cov
prevRho = rho
#}
# set up current age for eligibility criteria check for MDA
#compliance.mat[,1] <- scaled_numbers
compliance.mat[,1] <- all.mats.temp[,2]
compliance.mat[,1] <- scaled_numbers
compliance.mat[,4] <- (compliance.mat[,1] >= 5) & (compliance.mat[,1] < 80)
random_numbers <- runif(length(compliance.mat[,1]))
# Generate all random numbers at once
#random_numbers <- runif(length(compliance.mat[,1]))
compliance.mat[,5] <- runif(length(compliance.mat[,1]))
# Find indices of hosts meeting conditions
#eligible_hosts <- which((hostsEligibleAge) & (random_numbers < pTreat) & (neverTreat == 0))
compliance.mat[,6] <- ifelse(compliance.mat[,4] == 1 & compliance.mat[,5] < compliance.mat[,3] & compliance.mat[,2] == 0, 1, 0)
sum(compliance.mat[,6])/440
View(compliance.mat)
hostsEligibleAge <- (scaled_numbers >= 5) & (scaled_numbers < 80)
pTreat <- compliance.mat[,3]
neverTreat <- compliance.mat[,2]
neverTreat
random_numbers
pTreat
hostsEligibleAge
eligible_hosts <- which((hostsEligibleAge) & (random_numbers < pTreat) & (neverTreat == 0))
eligible_hosts
length(eligible_hosts)/440
eligible_hosts <- which(compliance.mat[,6] == 1)
eligible_hosts
View(compliance.mat)
length(eligible_hosts)/440
pnc = 0.05
#non-compliant people
non.comp <- ceiling(N * pnc)
non.comp
out.comp <- rep(0, N)
out.comp
s.comp <- sample(N, non.comp)
s.comp
out.comp[s.comp] <- 1
all.mats.tmp.test <- matrix(nrow = 4, ncol = N)
all.mats.tmp.test[,1] <- out.comp
length(out.comp)
out.comp[s.comp] <- 1
out.comp
all.mats.tmp.test[,1] <- out.comp
all.mats.tmp.test <- matrix(nrow = N, ncol = 4)
all.mats.tmp.test[,1] <- out.comp
treat.vec.in <- rep(NA, N) #for time since treatment calculations
treat.vec.in
treat.prob =  0.65
all.mats.tmp.test[,2] <- scaled_numbers
View(all.mats.tmp.test)
os.cov <- function(all.dt, pncomp, covrg, N)
{
pop.ages <- all.dt[,2] #age of each individual in population
iny <- which(pop.ages < 5 | all.dt[,1] == 1)
nc.age <- length(iny) / length(pop.ages)
covrg <- covrg / (1 - nc.age) # probability a complying individual will be treated
out.cov <- rep(covrg, length(pop.ages))
out.cov[iny] <- 0 # non-compliers get probability 0
f.cov <- rep(0, N)
r.nums <- runif(N, 0, 1)
inds.c <- which(r.nums < out.cov)
f.cov[inds.c] <- 1
return(f.cov)
}
cov.in <- os.cov(all.dt = all.mats.tmp.test, pncomp = pnc, covrg = treat.prob, N = N)
cov.in
background_prob <- 300/100000 # 300 per 100,000 person-years --> per-year
probability_blind <- function(mf) {
background_prob * exp(gamma1 * mf)
}
gamma0 <- 0
gamma1 <- 1E-02 # fitted for 2 yr lag in Little et al. 2004
mf <- seq(0, 1000, 1)
plot(probability_blind(mf)~mf)
prob <- probability_blind(mf)
blindness_df <- data.frame(fit = prob, mf = mf)
mf <- seq(0, 500, 1)
mf <- seq(0, 500, 1)
plot(probability_blind(mf)~mf)
prob <- probability_blind(mf)
blindness_df <- data.frame(fit = prob, mf = mf)
mf <- seq(0, 700, 1)
plot(probability_blind(mf)~mf)
prob <- probability_blind(mf)
blindness_df <- data.frame(fit = prob, mf = mf)
mf <- seq(0, 600, 1)
plot(probability_blind(mf)~mf)
prob <- probability_blind(mf)
blindness_df <- data.frame(fit = prob, mf = mf)
View(blindness_df)
mf <- seq(0, 580, 1)
plot(probability_blind(mf)~mf)
prob <- probability_blind(mf)
blindness_df <- data.frame(fit = prob, mf = mf)
write.csv(blindness_df, "eye_disease_probabilties_updated.csv")
write.csv(blindness_df, "eye_disease_probabilties_updated.csv")
saveRDS(blindness_df, "eye_disease_probabilties_updated.rds")
View(blindness_df)
devtools::load_all()
devtools::load_all()
#length of simulation in years
timesteps = 128
#should treatment be given, when and how often
give.treat.in = 1
treat.strt = 81; treat.stp = 128
trt.int = 1
#annual biting rate, which determines infection prevalence (60% microfilarae prevalence)
ABR.in = 843
#annual biting rate, which determines infection prevalence (60% microfilarae prevalence)
ABR.in = 1082
output <- ep.equi.sim(time.its = timesteps,
ABR = ABR.in,
N.in = 440,
treat.timing = NA,
treat.int = trt.int,
treat.prob.variable = NA,
give.treat = give.treat.in,
treat.start = treat.strt,
treat.stop = treat.stp,
pnc = 0.05,
min.mont.age = 5,
vector.control.strt = NA, #
delta.hz.in = 0.186,
delta.hinf.in = 0.003,
c.h.in = 0.005,
gam.dis.in = 0.3,
run_equilibrium = TRUE,
equilibrium = NA,
print_progress = TRUE,
correlated_compliance = "YES",
comp.correlation = 0.4)
output <- ep.equi.sim(time.its = timesteps,
ABR = ABR.in,
N.in = 440,
treat.timing = NA,
treat.int = trt.int,
treat.prob = 0.65,
treat.prob.variable = NA,
give.treat = give.treat.in,
treat.start = treat.strt,
treat.stop = treat.stp,
pnc = 0.05,
min.mont.age = 5,
vector.control.strt = NA, #
delta.hz.in = 0.186,
delta.hinf.in = 0.003,
c.h.in = 0.005,
gam.dis.in = 0.3,
run_equilibrium = TRUE,
equilibrium = NA,
print_progress = TRUE,
correlated_compliance = "YES",
comp.correlation = 0.4)
treat.strt = 1/366 + 1/366 + 1/366; treat.stp = 128
trt.int = 1
#annual biting rate, which determines infection prevalence (60% microfilarae prevalence)
# treat.prob.variable.in <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#                             0.14, 0.14, 0.14, 0.14, 0.14, 0.23, 0.23, 0.32, 0.32, 0.32, 0.32,
#                             0.42, 0.42, 0.42, 0.51, 0.51, 0.6, 0.69, 0.69, 0.69, 0.69, 0.69, 0.69,
#                             0, 0, 0)
#annual biting rate, which determines infection prevalence (60% microfilarae prevalence)
ABR.in = 1082
output <- ep.equi.sim(time.its = timesteps,
ABR = ABR.in,
N.in = 440,
treat.timing = NA,
treat.int = trt.int,
treat.prob = 0.65,
treat.prob.variable = NA,
give.treat = give.treat.in,
treat.start = treat.strt,
treat.stop = treat.stp,
pnc = 0.05,
min.mont.age = 5,
vector.control.strt = NA, #
delta.hz.in = 0.186,
delta.hinf.in = 0.003,
c.h.in = 0.005,
gam.dis.in = 0.3,
run_equilibrium = TRUE,
equilibrium = NA,
print_progress = TRUE,
correlated_compliance = "YES",
comp.correlation = 0.4)
devtools::load_all()
devtools::load_all()
#length of simulation in years
timesteps = 128
#should treatment be given, when and how often
give.treat.in = 1
treat.strt = 51; treat.stp = 128
#treat.strt = 1/366 + 1/366 + 1/366; treat.stp = 128
trt.int = 1
#annual biting rate, which determines infection prevalence (60% microfilarae prevalence)
# treat.prob.variable.in <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#                             0.14, 0.14, 0.14, 0.14, 0.14, 0.23, 0.23, 0.32, 0.32, 0.32, 0.32,
#                             0.42, 0.42, 0.42, 0.51, 0.51, 0.6, 0.69, 0.69, 0.69, 0.69, 0.69, 0.69,
#                             0, 0, 0)
#annual biting rate, which determines infection prevalence (60% microfilarae prevalence)
ABR.in = 1082
output <- ep.equi.sim(time.its = timesteps,
ABR = ABR.in,
N.in = 440,
treat.timing = NA,
treat.int = trt.int,
treat.prob = 0.65,
treat.prob.variable = NA,
give.treat = give.treat.in,
treat.start = treat.strt,
treat.stop = treat.stp,
pnc = 0.05,
min.mont.age = 5,
vector.control.strt = NA, #
delta.hz.in = 0.186,
delta.hinf.in = 0.003,
c.h.in = 0.005,
gam.dis.in = 0.3,
run_equilibrium = TRUE,
equilibrium = NA,
print_progress = TRUE,
correlated_compliance = "YES",
comp.correlation = 0.4)
